**一、逻辑回归与线性回归的联系与区别**

**应用场景：**线性回归主要用来解决连续值预测的问题，逻辑回归用来解决分类的问题，输出的属于某个类别的概率。

**参数估计：**

**1、**线性回归中使用的是最小化平方误差损失函数，对偏离真实值越远的数据惩罚越严重。这样做会有什么问题呢？假如使用线性回归对{0,1}二分类问题做预测，则一个真值为1的样本，其预测值为50，那么将会对其产生很大的惩罚，这也和实际情况不符合，更大的预测值说明为1的可能性越大，而不应该惩罚的越严重。
**2、**逻辑回归使用对数似然函数进行参数估计，使用交叉熵作为损失函数，对预测错误的惩罚是随着输出的增大，逐渐逼近一个常数，这就不存在上述问题了



**2、 逻辑回归的原理**

面对一个回归或者分类问题，建立代价函数，然后通过优化方法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。

Logistic回归虽然名字里带“回归”，但是它实际上是一种分类方法，主要用于两分类问题（即输出只有两种，分别代表两个类别）

回归模型中，y是一个定性变量，比如y=0或1，logistic方法主要应用于研究某些事件发生的概率



**3、逻辑回归损失函数推导及优化**

概率损失函数：P(y|x,θ) = (hθ(x))y * (1-hθ(x))1-y

取对数后得到对数似然函数：l(θ) = ∑(y*hθ(x) + (1-y)(1-hθ(x))

最大似然估计就是要求得使 l(θ)取最大值时的 θ ，这里可以使用梯度上升法求解。我们稍微变换一下： 

J(θ)=−1/m * l(θ)

**优化方法：**J(θ) = l(θ) + 1/m * ∑ θ2

**4、 正则化与模型评估指标**

（1） 过拟合问题 
过拟合即是过分拟合了训练数据，使得模型的复杂度提高，繁华能力较差（对未知数据的预测能力） 

（2）过拟合主要原因 
过拟合问题往往源自过多的特征 
解决方法 
1）减少特征数量（减少特征会失去一些信息，即使特征选的很好） 
• 可用人工选择要保留的特征； 
• 模型选择算法； 
2）正则化（特征较多时比较有效） 
• 保留所有特征，但减少θ的大小

（3）正则化方法 
正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或惩罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化项就越大。

正则项可以取不同的形式，在回归问题中取平方损失，就是参数的L2范数，也可以取L1范数。取平方损失时，模型的损失函数变为：

J(θ) = l(θ) + 1/m * ∑ θ2 

lambda是正则项系数： 
• 如果它的值很大，说明对模型的复杂度惩罚大，对拟合数据的损失惩罚小，这样它就不会过分拟合数据，在训练数据上的偏差较大，在未知数据上的方差较小，但是可能出现欠拟合的现象； 
• 如果它的值很小，说明比较注重对训练数据的拟合，在训练数据上的偏差会小，但是可能会导致过拟合。 
正则化后的梯度下降算法θ的更新变为：

θ = θ - λ/m *∑ (h(x)-y)*x - λ/m * θ



**5、逻辑回归的优缺点**

**优点：** 
1）速度快，适合二分类问题 
2）简单易于理解，直接看到各个特征的权重 
3）能容易地更新模型吸收新的数据 
**缺点：** 
对数据和场景的适应能力有局限性

**6、样本不均衡问题解决办法**

**1) 扩大数据集**
  当遇到类别不均衡问题时，首先应该想到，是否可能再增加数据（一定要有小类样本数据），更多的数据往往战胜更好的算法。因为机器学习是使用现有的数据多整个数据的分布进行估计，因此更多的数据往往能够得到更多的分布信息，以及更好分布估计。即使再增加小类样本数据时，又增加了大类样本数据，也可以使用放弃一部分大类数据（即对大类数据进行欠采样）来解决。
**2)尝试其它评价指标** 
  从前面的分析可以看出，准确度这个评价指标在类别不均衡的分类任务中并不能work，甚至进行误导（分类器不work，但是从这个指标来看，该分类器有着很好的评价指标得分）。因此在类别不均衡分类任务中，需要使用更有说服力的评价指标来对分类器进行评价。

**3)对数据集进行重采样** 
  可以使用一些策略该减轻数据的不平衡程度。该策略便是采样(sampling)，主要有两种采样方法来降低数据的不平衡性。

　　对小类的数据样本进行采样来增加小类的数据样本个数，即过采样（over-sampling ，采样的个数大于该类样本的个数）。
　　对大类的数据样本进行采样来减少该类数据样本的个数，即欠采样（under-sampling，采样的次数少于该类样本的个素）。
  采样算法往往很容易实现，并且其运行速度快，并且效果也不错。更详细的内容参见这里。 
  一些经验法则：　　考虑对大类下的样本（超过1万、十万甚至更多）进行欠采样，即删除部分样本；　　考虑对小类下的样本（不足1为甚至更少）进行过采样，即添加部分样本的副本；

　　考虑尝试随机采样与非随机采样两种采样方法；
　　考虑对各类别尝试不同的采样比例，比一定是1:1，有时候1:1反而不好，因为与现实情况相差甚远；
　　考虑同时使用过采样与欠采样。
**4)尝试产生人工数据样本** 
  一种简单的人工样本数据产生的方法便是，对该类下的所有样本每个属性特征的取值空间中随机选取一个组成新的样本，即属性值随机采样。你可以使用基于经验对属性值进行随机采样而构造新的人工样本，或者使用类似朴素贝叶斯方法假设各属性之间互相独立进行采样，这样便可得到更多的数据，但是无法保证属性之前的线性关系（如果本身是存在的）。 
  有一个系统的构造人工数据样本的方法SMOTE(Synthetic Minority Over-sampling Technique)。SMOTE是一种过采样算法，它构造新的小类样本而不是产生小类中已有的样本的副本，即该算法构造的数据是新样本，原数据集中不存在的。该基于距离度量选择小类别下两个或者更多的相似样本，然后选择其中一个样本，并随机选择一定数量的邻居样本对选择的那个样本的一个属性增加噪声，每次处理一个属性。这样就构造了更多的新生数据。具体可以参见原始论文。 
**5)尝试不同的分类算法** 
  强烈建议不要对待每一个分类都使用自己喜欢而熟悉的分类算法。应该使用不同的算法对其进行比较，因为不同的算法使用于不同的任务与数据。具体可以参见“Why you should be Spot-Checking Algorithms on your Machine Learning Problems”。 
  决策树往往在类别不均衡数据上表现不错。它使用基于类变量的划分规则去创建分类树，因此可以强制地将不同类别的样本分开。目前流行的决策树算法有：C4.5、C5.0、CART和Random Forest等。基于R编写的决策树参见这里。
**6)尝试对模型进行惩罚** 
  你可以使用相同的分类算法，但是使用一个不同的角度，比如你的分类任务是识别那些小类，那么可以对分类器的小类样本数据增加权值，降低大类样本的权值（这种方法其实是产生了新的数据分布，即产生了新的数据集，译者注），从而使得分类器将重点集中在小类样本身上。一个具体做法就是，在训练分类器时，若分类器将小类样本分错时额外增加分类器一个小类样本分错代价，这个额外的代价可以使得分类器更加“关心”小类样本。如penalized-SVM和penalized-LDA算法。 
  Weka中有一个惩罚模型的通用框架CostSensitiveClassifier，它能够对任何分类器进行封装，并且使用一个自定义的惩罚矩阵对分错的样本进行惩罚。 
  如果你锁定一个具体的算法时，并且无法通过使用重采样来解决不均衡性问题而得到较差的分类结果。这样你便可以使用惩罚模型来解决不平衡性问题。但是，设置惩罚矩阵是一个复杂的事，因此你需要根据你的任务尝试不同的惩罚矩阵，并选取一个较好的惩罚矩阵。



**7. sklearn参数**

class `sklearn.linear_model.`**LogisticRegression**(

**penalty**=’l2’, 参数类型：str，可选：‘l1’ or ‘l2’, 默认: ‘l2’。该参数用于确定惩罚项的范数

**dual**=False, 参数类型：bool,默认：False。双重或原始公式。使用liblinear优化器，双重公式仅实现l2惩罚。

**tol**=0.0001, 参数类型：float，默认：e-4。停止优化的错误率

**C**=1.0, 参数类型：float，默认；1。正则化强度的导数，值越小强度越大。

**fit_intercept**=True, 参数类型：bool，默认：True。确定是否在目标函数中加入偏置。

**intercept_scaling**=1, 参数类型：float，默认：1。仅在使用“liblinear”且self.fit_intercept设置为True时有用。

**class_weight**=None, 参数类型：dict，默认：None。根据字典为每一类给予权重，默认都是1.

**random_state**=None, 参数类型：int，默认：None。在打乱数据时，选用的随机种子。

**solver**=’warn’, 参数类型：str，可选：{‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’}, 默认：liblinear。选用的优化器。

**max_iter**=100, 参数类型：int，默认：100。迭代次数。**multi_class**=’warn’, 参数类型：str，可选：{‘ovr’, ‘multinomial’, ‘auto’}，默认：ovr。如果选择的选项是'ovr'，

　　那么二进制问题适合每个标签。对于“多项式”，最小化的损失是整个概率分布中的多项式损失拟合，即使数据是二进制的。当solver 　='liblinear'时，'multinomial'不

　　可用。如果数据是二进制的，或者如果solver ='liblinear'，'auto'选择'ovr'，否则选择'multinomial'。

**verbose**=0, 参数类型：int，默认：0。对于liblinear和lbfgs求解器，将详细设置为任何正数以表示详细程度。

**warm_start**=False, 参数类型：bool，默认：False。是否使用之前的优化器继续优化。

**n_jobs**=None，参数类型：bool，默认：None。是否多线程

)